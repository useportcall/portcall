// Code generated by portcall-gen. DO NOT EDIT.
// Generated at: 2026-01-22T22:25:24Z
//
// Run 'go run github.com/useportcall/portcall/sdks/go/cmd/portcall-gen generate' to regenerate.

package portcall

import (
	"context"
	"os"

	portcallsdk "github.com/useportcall/portcall/sdks/go"
)

// =============================================================================
// Configuration
// =============================================================================

// BaseURL is the Portcall API URL configured at generation time.
// Override with PC_API_URL environment variable or NewWithConfig.
const BaseURL = "http://localhost:8080"

// =============================================================================
// Plan IDs
// =============================================================================

// Plans contains all plan IDs in your Portcall app
var Plans = struct {
	DashboardFreeTier string
	DashboardProTier string
}{
	DashboardFreeTier: "plan_example_free_tier",
	DashboardProTier: "plan_example_pro_tier",
}

// Plan ID constants
const (
	PlanDashboardFreeTier = "plan_example_free_tier"
	PlanDashboardProTier = "plan_example_pro_tier"
)

// =============================================================================
// Feature IDs
// =============================================================================

// Features contains all feature IDs in your Portcall app
var Features = struct {
	MaxSubscriptions string
	NumberOfUsers string
}{
	MaxSubscriptions: "max_subscriptions",
	NumberOfUsers: "number_of_users",
}

// Feature ID constants
const (
	FeatureMaxSubscriptions = "max_subscriptions"
	FeatureNumberOfUsers = "number_of_users"
)

// MeteredFeatures contains only metered feature IDs
var MeteredFeatures = struct {
	MaxSubscriptions string
	NumberOfUsers string
}{
	MaxSubscriptions: "max_subscriptions",
	NumberOfUsers: "number_of_users",
}

// =============================================================================
// Plan Metadata
// =============================================================================

// PlanMeta contains metadata about a plan
type PlanMeta struct {
	ID              string
	Name            string
	Status          string
	Currency        string
	Interval        string
	IntervalCount   int
	TrialPeriodDays int
	IsFree          bool
}

// AllPlans contains metadata for all plans
var AllPlans = []PlanMeta{
	{ID: "plan_example_free_tier", Name: "Dashboard Free Tier", Status: "published", Currency: "USD", Interval: "month", IntervalCount: 1, TrialPeriodDays: 0, IsFree: true},
	{ID: "plan_example_pro_tier", Name: "Dashboard Pro Tier", Status: "draft", Currency: "USD", Interval: "month", IntervalCount: 1, TrialPeriodDays: 0, IsFree: false},
}

// GetPlanMeta returns the metadata for a plan by ID
func GetPlanMeta(planID string) *PlanMeta {
	for _, p := range AllPlans {
		if p.ID == planID {
			return &p
		}
	}
	return nil
}

// GetFreePlanMeta returns the first free plan metadata, if any
func GetFreePlanMeta() *PlanMeta {
	for _, p := range AllPlans {
		if p.IsFree {
			return &p
		}
	}
	return nil
}

// =============================================================================
// Feature Metadata
// =============================================================================

// FeatureMeta contains metadata about a feature
type FeatureMeta struct {
	ID        string
	IsMetered bool
}

// AllFeatures contains metadata for all features
var AllFeatures = []FeatureMeta{
	{ID: "max_subscriptions", IsMetered: true},
	{ID: "number_of_users", IsMetered: true},
}

// GetFeatureMeta returns the metadata for a feature by ID
func GetFeatureMeta(featureID string) *FeatureMeta {
	for _, f := range AllFeatures {
		if f.ID == featureID {
			return &f
		}
	}
	return nil
}

// IsMeteredFeature returns true if the feature is metered
func IsMeteredFeature(featureID string) bool {
	meta := GetFeatureMeta(featureID)
	return meta != nil && meta.IsMetered
}

// =============================================================================
// Client
// =============================================================================

// Client is the typed Portcall client with methods for your plans and features
type Client struct {
	SDK      *portcallsdk.Client
	Check    *CheckHelpers
	Checkout *CheckoutHelpers
	Record   *RecordHelpers
}

// New creates a new typed Portcall client.
// It reads PC_API_SECRET from environment and uses the BaseURL configured at generation time.
func New() *Client {
	return NewWithConfig(portcallsdk.Config{
		APIKey:  os.Getenv("PC_API_SECRET"),
		BaseURL: BaseURL,
	})
}

// NewWithConfig creates a new typed Portcall client with custom configuration.
func NewWithConfig(config portcallsdk.Config) *Client {
	if config.BaseURL == "" {
		config.BaseURL = BaseURL
	}
	sdk := portcallsdk.New(config)
	return &Client{
		SDK:      sdk,
		Check:    newCheckHelpers(sdk),
		Checkout: newCheckoutHelpers(sdk),
		Record:   newRecordHelpers(sdk),
	}
}

// =============================================================================
// Check Helpers (Entitlements)
// =============================================================================

// EntitlementChecker provides a fluent API for checking entitlements
type EntitlementChecker struct {
	sdk       *portcallsdk.Client
	featureID string
}

// For checks the entitlement for a specific user
func (e *EntitlementChecker) For(ctx context.Context, userID string) (*portcallsdk.Entitlement, error) {
	return e.sdk.Entitlements.Get(ctx, userID, e.featureID)
}

// IsEnabled checks if the entitlement is enabled for a user
func (e *EntitlementChecker) IsEnabled(ctx context.Context, userID string) (bool, error) {
	return e.sdk.Entitlements.IsEnabled(ctx, userID, e.featureID)
}

// GetRemaining returns the remaining quota for a user
func (e *EntitlementChecker) GetRemaining(ctx context.Context, userID string) (int64, error) {
	return e.sdk.Entitlements.GetRemaining(ctx, userID, e.featureID)
}

// GetUsage returns the full usage status for a user
func (e *EntitlementChecker) GetUsage(ctx context.Context, userID string) (*portcallsdk.QuotaStatus, error) {
	return e.sdk.Entitlements.GetUsage(ctx, userID, e.featureID)
}

// CheckHelpers provides typed entitlement checking for each feature
type CheckHelpers struct {
	MaxSubscriptions *EntitlementChecker
	NumberOfUsers *EntitlementChecker
}

func newCheckHelpers(sdk *portcallsdk.Client) *CheckHelpers {
	return &CheckHelpers{
		MaxSubscriptions: &EntitlementChecker{sdk: sdk, featureID: "max_subscriptions"},
		NumberOfUsers: &EntitlementChecker{sdk: sdk, featureID: "number_of_users"},
	}
}

// =============================================================================
// Checkout Helpers
// =============================================================================

// CheckoutCreator provides a fluent API for creating checkout sessions
type CheckoutCreator struct {
	sdk    *portcallsdk.Client
	planID string
}

// For creates a checkout session for a specific user
func (c *CheckoutCreator) For(ctx context.Context, userID, successURL, cancelURL string) (*portcallsdk.CheckoutSession, error) {
	return c.sdk.CheckoutSessions.Create(ctx, portcallsdk.CreateCheckoutSessionInput{
		UserID:      userID,
		PlanID:      c.planID,
		RedirectURL: successURL,
		CancelURL:   cancelURL,
	})
}

// CheckoutHelpers provides typed checkout session creation for each plan
type CheckoutHelpers struct {
	DashboardFreeTier *CheckoutCreator
	DashboardProTier *CheckoutCreator
}

func newCheckoutHelpers(sdk *portcallsdk.Client) *CheckoutHelpers {
	return &CheckoutHelpers{
		DashboardFreeTier: &CheckoutCreator{sdk: sdk, planID: "plan_example_free_tier"},
		DashboardProTier: &CheckoutCreator{sdk: sdk, planID: "plan_example_pro_tier"},
	}
}

// =============================================================================
// Record Helpers (Meter Events)
// =============================================================================

// UsageRecorder provides a fluent API for recording usage
type UsageRecorder struct {
	sdk       *portcallsdk.Client
	featureID string
}

// For records usage for a specific user
func (r *UsageRecorder) For(ctx context.Context, userID string, quantity int64) error {
	return r.sdk.MeterEvents.Record(ctx, userID, r.featureID, quantity)
}

// Increment increments usage by 1 for a specific user
func (r *UsageRecorder) Increment(ctx context.Context, userID string) error {
	return r.sdk.MeterEvents.Increment(ctx, userID, r.featureID)
}

// RecordHelpers provides typed usage recording for each metered feature
type RecordHelpers struct {
	MaxSubscriptions *UsageRecorder
	NumberOfUsers *UsageRecorder
}

func newRecordHelpers(sdk *portcallsdk.Client) *RecordHelpers {
	return &RecordHelpers{
		MaxSubscriptions: &UsageRecorder{sdk: sdk, featureID: "max_subscriptions"},
		NumberOfUsers: &UsageRecorder{sdk: sdk, featureID: "number_of_users"},
	}
}
